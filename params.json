{"name":"Rack-attack","tagline":"Rack middleware for blocking & throttling","body":"# Rack::Attack!!!\r\n*A DSL for blocking & throttling abusive clients*\r\n\r\nRack::Attack is a rack middleware to protect your web app from bad clients.\r\nIt allows *whitelisting*, *blacklisting*, *throttling*, and *tracking* based on arbitrary properties of the request.\r\n\r\nThrottle state is stored in a configurable cache (e.g. `Rails.cache`), presumably backed by memcached or redis.\r\n\r\n## Installation\r\n\r\nInstall the [rack-attack](http://rubygems.org/gems/rack-attack) gem; or add it to you Gemfile with bundler:\r\n\r\n    # In your Gemfile\r\n    gem 'rack-attack'\r\n\r\nTell your app to use the Rack::Attack middleware.\r\nFor Rails 3 apps:\r\n\r\n    # In config/application.rb\r\n    config.middleware.use Rack::Attack\r\n\r\nOr for Rackup files:\r\n\r\n    # In config.ru\r\n    use Rack::Attack\r\n\r\nOptionally configure the cache store for throttling:\r\n\r\n    Rack::Attack.cache.store = ActiveSupport::Cache::MemoryStore.new # defaults to Rails.cache\r\n\r\nNote that `Rack::Attack.cache` is only used for throttling; not blacklisting & whitelisting. Your cache store must implement `increment` and `write` like [ActiveSupport::Cache::Store](http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html).\r\n\r\n## How it works\r\n\r\nThe Rack::Attack middleware compares each request against *whitelists*, *blacklists*, *throttles*, and *tracks* that you define. There are none by default.\r\n\r\n * If the request matches any **whitelist**, it is allowed.\r\n * Otherwise, if the request matches any **blacklist**, it is blocked.\r\n * Otherwise, if the request matches any **throttle**, a counter is incremented in the Rack::Attack.cache. If the throttle limit is exceeded, the request is blocked.\r\n * Otherwise, all **tracks** are checked, and the request is allowed.\r\n\r\nThe algorithm is actually more concise in code: See [Rack::Attack.call](https://github.com/kickstarter/rack-attack/blob/master/lib/rack/attack.rb):\r\n\r\n    def call(env)\r\n      req = Rack::Request.new(env)\r\n\r\n      if whitelisted?(req)\r\n        @app.call(env)\r\n      elsif blacklisted?(req)\r\n        blacklisted_response[env]\r\n      elsif throttled?(req)\r\n        throttled_response[env]\r\n      else\r\n        tracked?(req)\r\n        @app.call(env)\r\n      end\r\n    end\r\n\r\n## About Tracks\r\n\r\n`Rack::Attack.track` doesn't affect request processing. Tracks are an easy way to log and measure requests matching arbitrary attributes.\r\n\r\n## Usage\r\n\r\nDefine whitelists, blacklists, throttles, and tracks as blocks that return truthy values if matched, falsy otherwise.\r\nA [Rack::Request](http://rack.rubyforge.org/doc/classes/Rack/Request.html) object is passed to the block (named 'req' in the examples).\r\n\r\n### Whitelists\r\n\r\n    # Always allow requests from localhost\r\n    # (blacklist & throttles are skipped)\r\n    Rack::Attack.whitelist('allow from localhost') do |req|\r\n      # Requests are allowed if the return value is truthy\r\n      '127.0.0.1' == req.ip\r\n    end\r\n\r\n### Blacklists\r\n\r\n    # Block requests from 1.2.3.4\r\n    Rack::Attack.blacklist('block 1.2.3.4') do |req|\r\n      # Request are blocked if the return value is truthy\r\n      '1.2.3.4' == req.ip\r\n    end\r\n\r\n    # Block logins from a bad user agent\r\n    Rack::Attack.blacklist('block bad UA logins') do |req|\r\n      req.path == '/login' && req.post? && req.user_agent == 'BadUA'\r\n    end\r\n\r\n### Throttles\r\n\r\n    # Throttle requests to 5 requests per second per ip\r\n    Rack::Attack.throttle('req/ip', :limit => 5, :period => 1.second) do |req|\r\n      # If the return value is truthy, the cache key for the return value\r\n      # is incremented and compared with the limit. In this case:\r\n      #   \"rack::attack:#{Time.now.to_i/1.second}:req/ip:#{req.ip}\"\r\n      #\r\n      # If falsy, the cache key is neither incremented nor checked.\r\n\r\n      req.ip\r\n    end\r\n\r\n    # Throttle login attempts for a given email parameter to 6 reqs/minute\r\n    Rack::Attack.throttle('logins/email', :limit => 6, :period => 60.seconds) do |req|\r\n      req.path == '/login' && req.post? && req.params['email']\r\n    end\r\n\r\n### Tracks\r\n\r\n    # Track requests from a special user agent\r\n    Rack::Attack.track(\"special_agent\") do |req|\r\n      req.user_agent == \"SpecialAgent\"\r\n    end\r\n\r\n    # Track it using ActiveSupport::Notification\r\n    ActiveSupport::Notifications.subscribe(\"rack.attack\") do |name, start, finish, request_id, req|\r\n      if req.env['rack.attack.matched'] == \"special_agent\" && req.env['rack.attack.match_type'] == :track\r\n        Rails.logger.info \"special_agent: #{req.path}\"\r\n        STATSD.increment(\"special_agent\")\r\n      end\r\n    end\r\n\r\n\r\n## Responses\r\n\r\nCustomize the response of blacklisted and throttled requests using an object that adheres to the [Rack app interface](http://rack.rubyforge.org/doc/SPEC.html).\r\n\r\n    Rack::Attack.blacklisted_response = lambda do |env|\r\n      [ 503, {}, ['Blocked']]\r\n    end\r\n\r\n    Rack::Attack.throttled_response = lambda do |env|\r\n      # name and other data about the matched throttle\r\n      body = [\r\n        env['rack.attack.matched'],\r\n        env['rack.attack.match_type'],\r\n        env['rack.attack.match_data']\r\n      ].inspect\r\n\r\n      [ 503, {}, [body]]\r\n    end\r\n\r\nFor responses that did not exceed a throttle limit, Rack::Attack annotates the env with match data:\r\n\r\n    request.env['rack.attack.throttle_data'][name] # => { :count => n, :period => p, :limit => l }\r\n\r\n## Logging & Instrumentation\r\n\r\nRack::Attack uses the [ActiveSupport::Notifications](http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html) API if available.\r\n\r\nYou can subscribe to 'rack.attack' events and log it, graph it, etc:\r\n\r\n    ActiveSupport::Notifications.subscribe('rack.attack') do |name, start, finish, request_id, req|\r\n      puts req.inspect\r\n    end\r\n\r\n## Performance\r\n\r\nThe overhead of running Rack::Attack is typically neglible (a few milliseconds per request),\r\nbut it depends on how many checks you've configured, and how long they take.\r\nThrottles usually require a network roundtrip to your cache server(s),\r\nso try to keep the number of throttle checks per request low.\r\n\r\nIf a request is blacklisted or throttled, the response is a very simple Rack response.\r\nA single typical ruby web server thread can block several hundred requests per second.\r\n\r\nRack::Attack complements tools like `iptables` and nginx's [limit_zone module](http://wiki.nginx.org/HttpLimitZoneModule).\r\n\r\n## Motivation\r\n\r\nAbusive clients range from malicious login crackers to naively-written scrapers.\r\nThey hinder the security, performance, & availability of web applications.\r\n\r\nIt is impractical if not impossible to block abusive clients completely.\r\n\r\nRack::Attack aims to let developers quickly mitigate abusive requests and rely\r\nless on short-term, one-off hacks to block a particular attack.\r\n\r\n[![Build Status](https://travis-ci.org/kickstarter/rack-attack.png?branch=master)](https://travis-ci.org/kickstarter/rack-attack)\r\n[![Code Climate](https://codeclimate.com/github/kickstarter/rack-attack.png)](https://codeclimate.com/github/kickstarter/rack-attack)\r\n\r\n## License\r\n\r\nCopyright (c) 2012 Kickstarter, Inc\r\n\r\nReleased under an [MIT License](http://opensource.org/licenses/MIT)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}